# 个别有难度的习题总结

## 重建二叉树（RebuildBinaryTree）
### 基本思路
- 根据前序找到根结点
- 根据中序找到该结点的左右子树的结点合集。
- 递归创建左右子树
### 难点分析
> **难点一在于左右子树的start,end,递归终止条件。**
- 左子树的pre_start好计算，在它前面只有根结点用了一个，所以pre_start = pstart+1.
- 左子树的pre_end就是pend。一直不变，因为它就是按顺序一个一个取的。
- 左子树的in_start也好计算，我们用for循环扫描了从start~end的中序序列，找到了root所在的index，记为mid。mid左边的（in_start~mid-1）是左子树的取值范围。mid右边的（mid+1~in_end）是右子树的取值范围。
----
- 右子树的pre_start比较难计算。它需要知道上一步【递归建立左子树用了多少个pre的结点】。上一步用的pre结点个数就是左子树的结点个数（即mid-1-in_start+1）。再加上root本身用了一个结点。所以pre_start = pre_start + mid - in_start+1。pre_end的位置就是pend。
- 右子树的in_start和in_end比较好计算，就是for循环中mid右边的那部分即in_start = mid+1,in_end = iend.

> **另一个难点就是递归终止条件。**
- pre/in的起始或结束越界表示无左/右子树，root的左/右子树置为null
- for循环，没有找到root在中序序列中的位置 则无左右子树。
- for循环中，根据root所在的位置，区分左右子树的存在情况
    - mid在for循环的起始位置【左子树为null】，则表示只有右子树。
    - mid在for循环的结束位置【右子树为null】，则表示只有左子树
    
难点总结：
- 正确计算出各个序列的start_index,end_index.
- 不遗漏递归的结束条件。左右子树是否存在要全面考虑。

## 重复数字
- 散列表 判重 常规解法
- 排序 再扫描一遍 不难想到
- index与array[index]的关系，有难度!
这题的第三种写法很讲究。但是看懂了思路也不难。书写起来可能有些绕，要注意！

## 二维数组查找（FindArray）
- 暴力解大家都会
- 每行元素进行二分查找，问题也不大
- 根据元素分布的特点，两个方向移动，缩小查找范围的确是不好想。但是看了这个思路，也知道具体怎么写了。

## 二叉树的下一个结点（GetNextInBinaryTree）
### 递归解法
- 先找出root结点。
- 然后中序遍历并记录遍历的序列。
- 扫描序列，找到指定点的下一个点
### 非递归解法
- 先找出root结点。
- 然后中序遍历并记录遍历的序列。
- 在遍历中找出符合要求的点。
    - 找到了pre点，标记flag为true，下次遍历时发现flag为true，说明下次遍历的点就是pre点中序序列的下一个结点。返回（return）这个点。
    
    